package net.guttershark.managers{	import flash.display.DisplayObject;	import flash.display.DisplayObjectContainer;		import net.guttershark.support.layoutmanager.Arrange;	/**	 * The LayoutManager Class is not a singleton, it decorates a	 * CoreClip or CoreSprite, and provides display list "layer"	 * arrangement methods.	 * 	 * @example	Using a layout manager.	 * <listing>		 * public class MyClip extends CoreClip	 * {	 *     public function MyClip()	 *     {	 *         super(); //critical	 *         var mc1:MovieClip = new MovieClip();	 *         //draw vector box in mc1 here...	 *         var mc2:MovieClip = new MovieClip();	 *         //draw vector box in mc2 here...	 *         var mc3:MovieClip = new MovieClip();	 *         //draw vector box in mc3 here...	 *         lm.addChildren(mc1,mc2,mc3); //shortcut to add multiple children.	 *         lm.arrange(Arrange.INFRONT,mc1,mc2); //moves mc1 in front of mc2	 *         lm.arrange(Arrange.SEND_TO_BACK,mc1); //sends mc1 all the way to the back.	 *         lm.arrange(Arrange.BRING_FORWARD,mc2); //brings mc2 forward (in front of mc3).	 *     }	 * }	 * </lsiting>	 * 	 * @see net.guttershark.display.CoreClip#lm CoreClip lm property	 * @see net.guttershark.display.CoreSprite#lm CoreSprite lm property	 */	public class LayoutManager	{		protected var _stage:DisplayObjectContainer;		/**		 * Constructor for LayoutManager instances. 		 */		public function LayoutManager(target:DisplayObjectContainer)		{			_stage = target;		}				/**		 * Arrange the target display object, relative to the supplied <em><code>relativeTo</code></em>		 * display object.		 * 		 * @param arrangement	An arrangement command (see: net.guttershark.support.layoutmanager.Arrange).		 * @param target	The target display object to re-arrange.		 * @param relativeTo	The display object in which the target will be relatively arranged from.		 */		public function arrange(arrangement:String,target:*,relativeTo:DisplayObject=null):void 		{			if(!_stage.contains(target)) return;			if(target === relativeTo) return;			var index:Number=-1;			switch(arrangement)			{				case Arrange.SEND_TO_BACK:					index = 0;					break;				case Arrange.BRING_TO_FRONT:					index = _stage.numChildren-1;					break;				case Arrange.SEND_BACKWARD:					index = Math.max(0,_stage.getChildIndex(target)-1);					break;				case Arrange.BRING_FORWARD:					index = _stage.getChildIndex(target)+1;					if(index == _stage.numChildren) return;					break;				case Arrange.BEHIND:					index = _stage.getChildIndex(relativeTo);					break;				case Arrange.INFRONT:					index = _stage.getChildIndex(relativeTo);					if(index < _stage.getChildIndex(target)) index +=1;					break;			}			if(index!=-1) _stage.setChildIndex(target,index);		}				/**		 * Add all children specified to the display list.		 * 		 * @param	...children	An array of display objects to add.		 */		public function addChildren(...children):void		{			for each(var child:DisplayObject in children) _stage.addChild(child);		}				/**		 * Add all children specified onto the display list of the target container.		 * 		 * @param	target	A display object to add the spefified children onto.		 * @param	...children	An array of display objects to add.		 */		public function addChildrenTo(target:DisplayObjectContainer,...children):void		{			for each(var child:DisplayObject in children) target.addChild(child);		}		/**		 * Remove all children specified from the display list.		 * 		 * @param ...children The children to remove.		 */		public function removeChildren(...children):void		{			for each(var child:DisplayObject in children) _stage.removeChild(child);		}				/**		 * Remove all children from the display list.		 */		public function removeAllChildren():void		{			if(_stage.numChildren<1) return;			try{while(_stage.removeChildAt(0)){}}catch(re:RangeError){}		}				/**		 * Remove all children from the display list of the specified target object.		 * 		 * @param	target	The target display object container whose children will be removed.		 */		public function removeAllChildrenFrom(target:DisplayObjectContainer):void		{			if(target.numChildren<1) return;			try{while(target.removeChildAt(0)){}}catch(re:RangeError){}		}	}}