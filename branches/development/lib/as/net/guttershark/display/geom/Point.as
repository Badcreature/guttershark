package net.guttershark.display.geom{	import net.guttershark.display.geom.IPoint;	import net.guttershark.util.math.TrigBase;	/**	 * Create a Point Object	 * @example var p:Point = new Point(10,10);	 */	public class Point implements IPoint 	{		public var x:Number;		public var y:Number;		/**		 * Constructor for Point instances.		 * @param nX The x coordinate.		 * @param nY The y coordinate.		 */		public function Point(nX:Number = 0, nY:Number = 0) 		{			super();			x = nX;			y = nY;		}		/**		 * Check if two Points match		 * 		 * @param p The Point to test equality against.		 * @return Boolean		 */		public function isEqual(p:Point):Boolean 		{			return (p.x==x&&p.y==y);		}		/**		 * Get distance between two points		 * 		 * @param p The Point whose distance will be calculated.		 * @return Number		 */		public function getDistance(p:Point):Number 		{			return TrigBase.getDistance(this,p);		}		/**		 * Algo to give the grid based distance when only vertical & horizontal moves are allowed		 * @param p The target Point		 * @return Number		 */		public function getAbsoluteGridDistance(p:Point):Number 		{			return Math.abs(x - p.x) + Math.abs(y - p.y);		}		/**		 * Algo to give the grid based distance when diagonal moves are allowed		 * by finding math.min of the differences, we're figuring out how many moves can be diagonal ones.		 * Then we can just substract that number from the normal .getAbsoluteGridDistance() method since diagonals take		 * 1 move instead of the usual 2		 * 		 * @param p The target Point.		 * @return Number		 */		public function getAbsoluteGridDistanceAllowDiagonals(p:Point):Number 		{			var offset:Number = Math.min(Math.abs(x - p.x),Math.abs(y - p.y));			return getAbsoluteGridDistance(p) - offset;		}		/**		 * Get the angle degree between this point and a second point.		 * 		 * @param p The target Point.		 * @return Number		 */		public function getAngle(p:Point):Number 		{			return Math.atan((this.y-p.y)/(this.x-p.x))/(Math.PI / 180);		}		/**		 * Returns a new point based on this point with x and y offset values.		 * @param nX (Number)		 * @param nY (Number)		 * @return Point		 */		public function displace(nX:Number, nY:Number):Point 		{			return new Point(x+nX,y+nY);		}		/**		 * Offset the Point object by a specified amount.		 * @param x (Number) horizontal offset		 * @param y (Number) vertical offset		 * @return Void		 */		public function offset(x:Number, y:Number):void 		{			this.x += x;			this.y += y;		}		/**		 * Rotate this Point around another Point by the specified angle.		 * @param p The target Point.		 * @param angle The angle to rotate around the target Point.		 * @return void		 */		public function rotate(p:Point,angle:Number):void 		{			var radians:Number = TrigBase.angle2radian(angle);			var baseX:Number = this.x - p.x;			var baseY:Number = this.y - p.y;			this.x = (Math.cos(radians) * baseX) - (Math.sin(radians) * baseY) + p.x;			this.y = (Math.sin(radians) * baseX) + (Math.cos(radians) * baseY) + p.y;			}			/**		 * Clone this Point.		 * @return Point		 */		public function clone():Point 		{			return new Point(this.x,this.y);		}				}}