package net.guttershark.display.video{	import flash.display.Sprite;
	import flash.events.EventDispatcher;
	import flash.events.NetStatusEvent;
	import flash.events.TimerEvent;
	import flash.media.SoundTransform;
	import flash.media.Video;
	import flash.net.NetConnection;
	import flash.net.NetStream;
	import flash.utils.Timer;
	import flash.utils.setTimeout;
	
	import net.guttershark.support.events.FLVEvent;
	import net.guttershark.util.MathUtils;		
	/* 	 * The standard netStream.bufferTime will fire cuePoints out of order	 * so custom smart buffer is utilized.	 * http://www.restlessthinker.com/blog/?p=44	 */
	/**	 * FLV provides a common media control object.	 */	public class FLV extends Sprite	{				/**		 * The net stream object.		 */		protected var stream:NetStream;				/**		 * The net connection for the flv.		 */		protected var nc:NetConnection;				/**		 * The video object.		 */		protected var display:Video;				/**		 * The url currently playing.		 */
		protected var url:String;				/**		 * Pased flag.		 */		protected var paused:Boolean;				/**		 * Started flag.		 */		protected var started:Boolean;				/**		 * The duration of the current flv.		 */		protected var duration:Number;				/**		 * Meta data.		 */		protected var metadata:Object;				/**		 * The last seekable time.		 */		protected var lastSeekableTime:Number;				/**		 * The buffer time for the flv.		 */		protected var bufferTime:Number;				/**		 * Flag for internal custom buffer logic.		 */		protected var bufferPause:Boolean;				/**		 * The math utils singleton.		 */		protected var mu:MathUtils;		/**		 * A timer that polls the net stream for status.		 */		private var checkTimer:Timer;				/**		 * The amount of pixels to use when calculating		 * how many pixels have played, as well has how		 * many buffer pixels are full.		 */		protected var pixelsToFill:int;		/**		 * Constructor for FLV instances.		 * 		 * @param width The width of the video object.		 * @param height The height of the video object.		 * @param smoothing Whether or not smoothing is applied.		 * @param updateInterval The millisecond interval to poll for progress and buffer.		 * @param pixelsToFill The amount of pixels to fill for a progress status bar.		 */		public function FLV(width:int=320,height:int=240,smoothing:Boolean=true,pixelsToFill:int=100,updateIntervalMS:int=400)		{			super();			mu = MathUtils.gi();			checkTimer = new Timer(400);			checkTimer.addEventListener(TimerEvent.TIMER,ontick);			nc = new NetConnection();			nc.connect(null);			stream = new NetStream(nc);			stream.client = this;			stream.addEventListener(NetStatusEvent.NET_STATUS,onNSStatus,false,0,true);			display = new Video(width,height);			display.attachNetStream(stream);			display.smoothing = smoothing;			this.pixelsToFill = pixelsToFill;			paused = false;			started = false;			duration = 1000000000; //fix for buffer bar flakiness		}		/**		 * Loads the video, and optionally shows the first frame.		 * 		 * @param url The url of the FLV to load.		 * @param buffer Seconds of buffer to maintain.		 * @param showFirstFrame Whether or not to show the first frame of the flv.		 */		public function load(url:String,buffer:uint=4,showFirstFrame:Boolean=true):void		{			this.url = url;			bufferTime = buffer;						checkTimer.start();			play();			pause();			if(showFirstFrame) setTimeout(seek,500,0);		}				/**		 * Play the flv.		 */		public function play():void		{			display.clear();			started = true;			paused = false;			stream.seek(0);			stream.play(url);		}		/**		 * Stop the flv.		 */		public function stop():void		{			stream.pause();			started = false;			paused = false;		}		/**		 * Pause the flv.		 */		public function pause():void 		{			if(!paused && started)			{				paused = true;				stream.pause();			}		}		/**		 * Resume the flv playback.		 */		public function resume():void		{			if(paused && started)			{				paused = false;				stream.resume();			}		}		/**		 * Pauses or resumes the flv.		 */		public function pauseResume():void		{			if(paused) resume();			else pause();		}		/**		 * Seek to a playback time - note that unless you're using		 * a flash media server, it will only seek to the nearest		 * key frame (i-frame) (see video docs in flash help for more info).		 * 		 * @param time The time in seconds to seek to.		 */		public function seek(time:Number):void		{			stream.seek(resolveTime(time));		}		/**		 * Seek to a playback percent.		 * 		 * @param percent of playback to seek to.		 */		public function seekToPercent(percent:Number):void		{			seek(duration*percent/100);		}				/**		 * Seek to a width based off of the pixels to fill		 * (pixelsToFill) property. For example, if the pixels		 * to fill was 300, you could seek anywhere between		 * 0-300.		 * 		 * @param pixel The width to seek to.		 */		public function seekToPixel(pixel:int):void		{			seek(resolveTime(mu.spread(pixel,pixelsToFill,duration)));		}		/**		 * Fast-forward playback.		 * 		 * @param step seconds to step forward.		 */		public function forward(step:Number = 2):void		{			seek(getTime()+step);		}		/**		 * Rewind playback.		 * 		 * @param step seconds to step backwards.		 */		public function rewind(step:Number = 2):void 		{			seek(getTime()-step);		}				/**		 * Check if the FLV is paused.		 */		public function isPaused():Boolean		{			return paused;		}		/**		 * Check if the FLV is playing.		 */		public function isPlaying():Boolean 		{			return started;		}		/**		 * Check if the FLV is stopped.		 */		public function isStopped():Boolean		{			return !started;		}		/**		 * Return the playback time.		 */		public function getTime():Number		{			return stream.time;		}		/**		 * Return the total playback duration.		 */		public function getDuration():Number		{				return duration;		}		/**		 * Return the percent played.		 */		public function get percentPlayed():Number		{			return getTime() * 100 / duration;		}						/**		 * Return the percent loaded.		 */		public function get percentLoaded():Number		{			return Math.round(stream.bytesLoaded/stream.bytesTotal*100);		}		/**		 * Return the percent buffered.		 */		public function get percentBuffered():Number		{			var total:Number = Math.min(duration,bufferTime);			return Math.min(Math.round(stream.bufferLength/total*100),100);		}				/**		 * Returns a value you can map to a display object for		 * width, height, or any other operation that needs		 * to show a pixel representation of how much buffer		 * is currently in the stream.		 */		public function get pixelsBuffered():Number		{			var total:Number = Math.min(duration,bufferTime);			return mu.spread(stream.bufferLength,total,pixelsToFill);			//return Math.min((stream.bufferLength/total)*pixelsToFill,pixelsToFill);		}				/**		 * Returns a value you can map to a display object for		 * width, height, or any other operation that needs		 * to show a pixel representation of how much of the		 * video has played.		 */		public function get pixelsPlayed():Number		{			return mu.spread(getTime(),duration,pixelsToFill);		}						/**		 * Set the video volume.		 * 		 * @param volume The volume level - 0-1.		 */		public function set volume(volume:Number):void		{			var st:SoundTransform = stream.soundTransform;			st.volume = volume;			stream.soundTransform = st;		}				/**		 * The volume of the video player.		 */		public function get volume():Number		{			var st:SoundTransform = stream.soundTransform;			return st.volume;		}				/**		 * The sound transform of the stream.		 */		override public function get soundTransform():SoundTransform		{			if(stream) return stream.soundTransform;			return null;		}		/**		 * The internal video object used to display the		 * flv.		 */		public function get video():Video		{			return display;			}		/**		 * The internal net stream used for the flv.		 */		public function get netStream():NetStream		{			return stream;			}		/**		 * @private		 * 		 * Formats time so that it fits inside the available seek scope.		 * 		 * @param time The time from the net stream.		 */		protected function resolveTime(time:Number):Number		{			var maxTime:Number = (!isNaN(lastSeekableTime))?lastSeekableTime:duration;			return Math.max(Math.min(time,maxTime),0);		}		/**		 * Stop playback and cleanup after self.		 */		public function dispose():void		{			stop();			checkTimer.stop();			checkTimer.removeEventListener(TimerEvent.TIMER,ontick);			stream.removeEventListener(NetStatusEvent.NET_STATUS,onNSStatus);			display.clear();			stream.close();			nc.close();			display = null;			stream = null;			nc = null;		}				/**		 * @private		 * 		 * Handles buffer logic, instead of using net stream		 * buffer time.		 */		protected function checkBuffer():void		{			if(percentLoaded <= percentBuffered) //no buffer.			{				if(percentLoaded >= 1) return; //video complete				if(!bufferPause) dispatchEvent(new FLVEvent(FLVEvent.REBUFFER));				bufferPause = true;			}			else			{				if(bufferPause)				{					bufferPause = false;					dispatchEvent(new FLVEvent(FLVEvent.REBUFFER_COMPLETE));				}			}		}		/**		 * @private		 * 		 * Progress frame loop to keep client progress up to date.		 */		protected function ontick(te:TimerEvent):void		{			trace("tick",pixelsPlayed);			dispatchEvent(new FLVEvent(FLVEvent.PROGRESS,NaN,percentLoaded,percentPlayed));			//if(getPercentLoaded() == 1) FramePulse.RemoveEnterFrameListener(onProgress);			checkBuffer();		}		/**		 * @private		 * 		 * NetStatus handler.		 */		protected function onNSStatus(stats:NetStatusEvent):void		{			trace("netstat: ",stats.info['code']);			switch (stats.info['code'])			{				case "NetStream.Buffer.Empty":					dispatchEvent(new FLVEvent(FLVEvent.BUFFER_EMPTY));					break;				case "NetStream.Buffer.Full":					dispatchEvent(new FLVEvent(FLVEvent.BUFFER_FULL));					break;				case "NetStream.Buffer.Flush":					dispatchEvent(new FLVEvent(FLVEvent.BUFFER_FLUSH));					break;				case "NetStream.Play.Start":					dispatchEvent(new FLVEvent(FLVEvent.START));					break;				case "NetStream.Play.Stop":					dispatchEvent(new FLVEvent(FLVEvent.STOP));					break;				case "NetStream.Play.StreamNotFound":					dispatchEvent(new FLVEvent(FLVEvent.STREAM_NOT_FOUND));					break;				case "NetStream.Seek.InvalidTime":					dispatchEvent(new FLVEvent(FLVEvent.SEEK_INVALID_TIME));					break;				case "NetStream.Seek.Notify":					dispatchEvent(new FLVEvent(FLVEvent.SEEK_NOTIFY));					break;			}					}		/**		 * @private		 * 		 * Net CuePoint handler.		 */		public function onCuePoint(infoObject:Object):void		{ 			dispatchEvent(new FLVEvent(FLVEvent.CUE_POINT,NaN,NaN,null,infoObject));		}		/**		 * @private		 * 		 * Meta data handler.		 */		public function onMetaData(metadata:Object):void		{			metadata = metadata;			duration = metadata.duration;			lastSeekableTime = metadata.lastkeyframetimestamp;			dispatchEvent(new FLVEvent(FLVEvent.METADATA,NaN,NaN,metadata));		}							}}		