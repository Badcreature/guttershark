package net.guttershark.managers{	import net.guttershark.support.soundmanager.AudibleGroup;
	import net.guttershark.util.Singleton;
	
	import flash.events.EventDispatcher;
	import flash.media.Sound;
	import flash.utils.Dictionary;	
	/**	 * The SoundManager class simplifies managing sounds. There are a few	 * key things to understand before using the sound manager.	 * 	 * <p><strong>Audibles</strong></p>	 * <p>An "audible" represents an object that you can hear - meaning	 * an instance of a Sound object, or any object that has a "soundTransform"	 * property on it. You can control these objects with the sound	 * manager.</p>	 * 	 * <p><strong>Group Audibles</strong></p>	 * <p>A group audible, is a collection of audibles you can control	 * as a group, or you can control a single audible within a group,	 * which acts as a sandbox for containing audio options in a group.</p>	 * 	 * <p><strong>Local Audibles</strong></p>	 * <p>A local audible, is an audible object that isn't part of	 * any group, you can control that audible object by itself.</p>	 * 	 * <p>This may seem confusing, or too much. But if you've ever built	 * a website where a lot of sounds were involved, you'd wish	 * you had something like this, I know I did. This will simplify how	 * you play sounds, options that control sounds, grouping sounds to keep	 * them at a consistent level, controlling groups of sounds, etc. You	 * can probably start to see how useful this is.</p>	 * 	 * <p>There is one step you must do for every audible object	 * you want to be able to control. You must add it to the	 * manager first. (see the<em>addAudible</em> method).</p>	 * 	 * <p>After you've done that, you can now control it as a local	 * audible, or put it into a group, or multiple groups!</p>	 * 	 * @example Simple example controlling a "local" audible.	 * <listing>	 * var snm:SoundManager=SoundManager.gi();	 * snm.addAudible("starburst",assetManager.getSound("Starburst"));	 * snm.playAudible("starburst",{volume:.3,loops:2});	 * </listing>	 * 	 * @example Setting up an audible group.	 * <listing>	 * var snm:SoundManager=SoundManager.gi();	 * snm.addAudible("warehouse",assetManager.getSound("WareHouseAmbient"));	 * snm.addAudible("cherryPicker",assetManager.getSound("CherryPicker"));	 * snm.createAudibleGroup("warehouseEnvironment",{maxVolume:.4},"warehouse","cherryPicker");	 * 	 * //create home sounds.	 * 	 * public var homeButton:MovieClip;	 * public var warehouseButton:MovieClip;	 * 	 * homeButton.addEventListener(MouseEvent.CLICK,onHome);	 * warehouseButton.addEventListener(MouseEvent.CLICK,onWarehouse);	 * 	 * //TODO: Complete this example.	 * 	 * function onHome(e:MouseEvent):void	 * {	 *     clearTimeout(randomCherryPickerSoundTimeout);	 *     snm.stopGroup("warehouseEnvironment");	 *     snm.playGroup("homeSounds");	 * }	 * 	 * var randomCherryPickerSoundTimeout;	 * private function onWarehouse(e:MouseEvent):void	 * {	 *     snm.stopGroup("home");	 *     snm.playAudibleFromGroup("warehouseEnvironment","warehouse",{loops:10000});	 *     cherryPickerSoundRandom();	 * }	 * 	 * private function cherryPickerSoundRandom():void	 * {	 *     randomCherryPickerSoundTimeout=setTimeout(cherryPickerSoundRandom,utils.math.randInteger(4000,15000));	 *     snm.playAudibleFromGroup("warehouseEnvironment","cherryPicker",{onStart:onCherryPickerSoundStart});	 * }	 * 	 * function onCherryPickerSoundStart():void	 * {	 *     trace("cherry picker is playing again");	 * }	 * </listing>	 * 	 * addSound(id:String,snd:Sound,op:Object);	 * maxVolume	 * minVolume	 * allowMute	 * 	 * snm.addSound("test",am.getSound("Test"),{maxVolume:.4});	 * 	 * TODO Unit tests AudibleGroup	 * TODO Unit tests AudibleObject	 * TODO Finish and test SoundManager3	 */	final public class SoundManager3 extends EventDispatcher	{				/**		 * The amount of currently used audio channels - 32		 * is maximum in flash 9.		 */		public static var USED_CHANNELS:Number;				/**		 * Singleton instance.		 */		private static var inst:SoundManager3;				/**		 * All audible objects that have been registered.		 */		private var audibles:Dictionary;				/**		 * All audible groups that have been created.		 */		private var audibleGroups:Dictionary;				/**		 * An internal group used to manage audible objects		 * that aren't in a group.		 */		private var _internalGroup:AudibleGroup;				/**		 * @private		 * 		 * Singleton SoundManager		 */		public function SoundManager3()		{			Singleton.assertSingle(SoundManager3);			USED_CHANNELS=0;			audibleGroups=new Dictionary();			audibles=new Dictionary();		}		/**		 * Singleton access.		 */		public static function gi():SoundManager3		{			if(!inst)inst=Singleton.gi(SoundManager3);			return inst;		}				/**		 * A warning trace when a group does not exist.		 * 		 * @param groupId The group id to warn about.		 */		private function warnNoGroup(groupId:String):void		{			trace("WARNING: The group {"+groupId+"} does not exist. Nothing done.");		}				/**		 * Checks whether or not a group exists.		 * 		 * @param groupId The group id.		 */		public function doesGroupExist(groupId:String):Boolean		{			return !(audibleGroups[groupId]==undefined);		}				/**		 * Check whether or not an audible is in any group.		 * 		 * @param audibleId The audible object id.		 */		public function isAudibleInAnyGroup(audibleId:String):Boolean		{			var group:AudibleGroup;			for each(group in audibleGroups)if(group.hasAudible(audibleId))return true;			return false;		}				/**		 * Add an audible object to the manager.		 * 		 * @param id The audible object's id.		 * @param obj The audible object. (A Sound, or an object with a soundTransform property).		 */		public function addAudible(audibleId:String,obj:*):void		{			if(!(obj is Sound) && !("soundTransform" in obj)) throw new Error("The volume cannot be controlled for the added object, it must be a Sound object, or have a {soundTransform property.}");			_internalGroup.addAudible(audibleId,obj);			audibles[audibleId]=obj;		}				/**		 * Add an audible object to an existing group.		 * 		 * @param groupId The group id.		 * @param audibleId The audible object id.		 * @param obj The audible object (a Sound, or an object with a soundTransform property).		 */		public function addAudibleToGroup(groupId:String,audibleId:String,obj:*):void		{			if(!doesGroupExist(groupId)) warnNoGroup(groupId);			var group:AudibleGroup=audibleGroups[groupId];			group.addAudible(audibleId,obj);			audibles[audibleId]=obj;		}				/**		 * Add an audible to multiple groups.		 * 		 * @param audibleId The id of the audible.		 * @param obj The audible object to control.		 * @param groupIds The group ids to add the audible to.		 */		public function addAudibleToGroups(audibleId:String,obj:*,...groupIds:Array):void		{			if(!groupIds)return;			var i:int=0;			var l:int=groupIds.length;			for(i;i<l;i++)			{				if(!doesGroupExist(groupIds[i]))continue;				AudibleGroup(audibleGroups[groupIds[i]]).addAudible(audibleId,obj);			}		}				/**		 * TODO DOC		 */		public function muteAudidble(audibleId:String):void		{			_internalGroup.muteAudible(audibleId);		}
				/**		 * Create a new audible group.		 * 		 * minVolume		 * maxVolume		 * allowMute		 * 		 * @param groupId The group id.		 * @param groupOptions Options to apply to the group.		 * @param ...audibleIds A list of id's which should be auto added to the new group.		 */		public function createAudibleGroup(groupId:String,groupOptions:Object,...audibleIds:Array):void		{			var group:AudibleGroup=new AudibleGroup(groupId);			var i:int=0;			var l:int=audibleIds.length;			for(i;i<l;i++) group.addAudible(audibleIds[i],audibles[audibleIds[i]]);			audibleGroups[groupId]=group;		}				/**		 * Move an audible object from one group to a different group.		 * 		 * @param audibleId The audible id.		 * @param curGroupId The current group the audible object lives in.		 * @param newGroupid The new group id to move the audible objec to.		 */		public function moveAudibleFromGroupToGroup(audibleId:String,curGroupId:String,newGroupId:String):void		{			var cgroup:AudibleGroup=audibleGroups[curGroupId];			if(!doesGroupExist(newGroupId))warnNoGroup(newGroupId);			var ngroup:AudibleGroup=audibleGroups[newGroupId];			var obj:* =cgroup.getRawAudible(audibleId);			cgroup.removeAudible(audibleId);			ngroup.addAudible(audibleId,obj);		}				/**		 * Remove a local audible object, but not from any		 * audible groups.		 * 		 * @param audibleId The audible object id.		 */		public function removeAudible(audibleId:String):void		{			_internalGroup.removeAudible(audibleId);			audibles[audibleId]=null;			delete audibles[audibleId];		}				/**		 * Remove an audible from a specific group.		 * 		 * @param groupId The group to remove the audible from.		 * @param audibleId The audible to remove.		 */		public function removeAudibleFromGroup(groupId:String,audibleId:String):void		{			if(!doesGroupExist(groupId))return;			AudibleGroup(audibleGroups[groupId]).removeAudible(audibleId);		}		/**		 * Remove an audible from the provided group ids, or if null,		 * all groups that the audible resides in.		 * 		 * @param audibleId The audible object id.		 * @param ...groupIds The group ids.		 */		public function removeAudibleFromGroups(audibleId:String,...groupIds:Array):void		{			var group:AudibleGroup;			if(!groupIds) for each(group in audibleGroups)group.removeAudible(audibleId);			else			{				var i:int=0;				var l:int=groupIds.length;				for(i;i<l;i++)				{					if(!doesGroupExist(groupIds[i]))continue;					AudibleGroup(audibleGroups[groupIds[i]]).removeAudible(audibleId);				}			}		}				/**		 * Destroy an audible group.		 * 		 * @param groupId The group id. 		 */		public function destroyAudibleGroup(groupId:String):void		{			if(!doesGroupExist(groupId))return;			var group:AudibleGroup=audibleGroups[groupId];			group.dispose();			audibleGroups[groupId]=null;			delete audibleGroups[groupId];		}				/**		 * Play all local audibles.		 */		public function play():void		{			_internalGroup.playAll();		}		/**		 * Play all local audibles, and all groups.		 */		public function playAll(groupPlayOptions:Object=null):void		{			_internalGroup.playAll(groupPlayOptions);			var group:AudibleGroup;			for each(group in audibleGroups)group.playAll(groupPlayOptions);		}		/**		 * Play a local audible object.		 * 		 * @param audibleId The audible id.		 * @param options Play options for.		 */		public function playAudible(audibleId:String,options:Object=null):void		{			_internalGroup.playAudible(audibleId,options);		}				/**		 * Play all audibles in a group.		 * 		 * @param groupId The group id.		 */		public function playGroup(groupId:String):void		{			if(!doesGroupExist(groupId)) warnNoGroup(groupId);			var group:AudibleGroup=audibleGroups[groupId];			group.playAll();		}				/**		 * Play the groups specified, or if null,		 * all groups will play, but not any local audibles.		 * 		 * @param ...groupIds		 */		public function playGroups(...groupIds:Array):void		{			var group:AudibleGroup;			if(!groupIds) for each(group in audibleGroups)group.playAll();			else			{				var i:int=0;				var l:int=groupIds.length;				for(i;i<l;i++)				{					if(!doesGroupExist(groupIds[i]))continue;					AudibleGroup(audibleGroups[groupIds[i]]).playAll();				}			}		}				/**		 * Play an audible object that exists in a group.		 * 		 * @param groupId The group id.		 * @param audibleId The audible id.		 * @param options Play options.		 */		public function playAudibleFromGroup(groupId:String,audibleId:String,options:Object):void		{			if(!doesGroupExist(groupId)) warnNoGroup(groupId);			var group:AudibleGroup=audibleGroups[groupId];			group.playAudible(audibleId,options);		}				/**		 * Check whether or not a local audible object is playing.		 * 		 * @param audibleId The audible id.		 */		public function isAudiblePlaying(audibleId:String):Boolean		{			return _internalGroup.isAudiblePlaying(audibleId);		}				/**		 * Check whether or not an audible object in a group is playing.		 * 		 * @param groupId The group id.		 * @param audibleId The audible id.		 */		public function isAudibleInGroupPlaying(groupId:String,audibleId:String):Boolean		{			return AudibleGroup(audibleGroups[groupId]).isAudiblePlaying(audibleId);		}		/**		 * Check if an audible is playing in any group.		 * 		 * @param audibleId The audible id.		 */		public function isAudiblePlayingInAnyGroup(audibleId:String):Boolean		{			var group:AudibleGroup;			for each(group in audibleGroups)if(group.isAudiblePlaying(audibleId))return true;			return false;		}				/**		 * Stop a local audible.		 * 		 * @param audibleId The audible id.		 */		public function stopAudible(audibleId:String):void		{			_internalGroup.stopAudible(audibleId);		}				/**		 * Stop an audible that's playing in a specific group.		 * 		 * @param groupId The group id.		 * @param audibleId The audible id.		 */		public function stopAudibleInGroup(groupId:String,audibleId:String):void		{			if(!doesGroupExist(groupId))return;			AudibleGroup(audibleGroups[groupId]).stopAudible(audibleId);		}				/**		 * Stop an audible from the groups provided, or if no groups are		 * provided, it stops the audible in all groups.		 * 		 * @param audibleId The audible to stop.		 * @param ...groupIds The group ids to stop the audible in.		 */		public function stopAudibleInGroups(audibleId:String,...groupIds:Array):void		{			var group:AudibleGroup;			if(!groupIds)for each(group in audibleGroups)group.stopAudible(audibleId);			else			{				var i:int=0;				var l:int=groupIds.length;				for(i;i<l;i++)				{					if(!doesGroupExist(groupIds[i]))continue;					group=audibleGroups[groupIds[i]];					if(group.stopAudible(audibleId));				}			}		}				/**		 * Pause all local audibles, but not any groups.		 */		public function pause():void		{			_internalGroup.pause();		}		/**		 * Pause all local audibles, and every group.		 */		public function pauseAll():void		{			_internalGroup.pause();			var group:AudibleGroup;			for each(group in audibleGroups)group.pause();		}		/**		 * Pause all groups provided, or if null, pause		 * all groups.		 * 		 * @param ...groupIds The group ids to pause.		 */		public function pauseGroups(...groupIds:Array):void		{			var group:AudibleGroup;			if(!groupIds)for each(group in audibleGroups)group.pause();			else			{				var i:int=0;				var l:int=groupIds.length;				for(i;i<l;i++)				{					if(!doesGroupExist(groupIds[i]))continue;					AudibleGroup(audibleGroups[groupIds[i]]).pause();				}			}		}				/**		 * Resume local audibles.		 */		public function resume():void		{			_internalGroup.resume();		}		/**		 * Resume all local audibles and groups.		 */		public function resumeAll():void		{			var group:AudibleGroup;			for each(group in audibleGroups)group.resume();		}				/**		 * Resume the group ids provided, or if null,		 * resume all groups, but not any local audibles.		 */		public function resumeGroups(...groupIds:Array):void		{			var group:AudibleGroup;			if(!groupIds)for each(group in audibleGroups)group.resume();			else			{				var i:int=0;				var l:int=groupIds.length;				for(i;i<l;i++)AudibleGroup(audibleGroups[groupIds[i]]).resume();			}		}				/**		 * Stop local audibles playing.		 */		public function stop():void		{			_internalGroup.stop();		}				/**		 * Stop local audibles, and all groups.		 */		public function stopAll():void		{			_internalGroup.stop();			var group:AudibleGroup;			for each(group in audibleGroups)group.stop();		}				/**		 * Stop all groups provided, or if null,		 * stop all groups.		 * 		 * @param ...groupIds The groups to stop.		 */		public function stopGroups(...groupIds:Array):void		{			var group:AudibleGroup;			if(!groupIds)for each(group in audibleGroups)group.stop();			else			{				var i:int=0;				var l:int=groupIds.length;				for(i;i<l;i++)AudibleGroup(audibleGroups[groupIds[i]]).stop();			}		}				/**		 * Increase the volume for all local audibles, but		 * not any groups.		 * 		 * @param step The amount to increase the volume level by.		 */		public function increaseVolume(step:Number=.1):void		{			_internalGroup.increaseVolume(step);		}		/**		 * Increase a group's volume.		 * 		 * @param groupId The group id.		 * @param step The amount to increase the volume level by.		 */		public function increaseVolumeForGroup(groupId:String,step:Number=.1):void		{			var group:AudibleGroup = audibleGroups[groupId];			group.increaseVolume(step);		}				/**		 * Increase the group ids provided, or if null,		 * all groups, but not any local audibles.		 * 		 * @param step The amount to increase the volume by.		 * @param ...groupIds The group ids whose volume should be increased.		 */		public function increaseVolumeForGroups(step:Number=.1,...groupIds:Array):void		{			var group:AudibleGroup;			if(!groupIds) for each(group in audibleGroups) group.increaseVolume(step);			else			{				var i:int=0;				var l:int=groupIds.length;				for(i;i<l;i++)AudibleGroup(audibleGroups[groupIds[i]]).increaseVolume(step);			}		}		/**		 * Decrease the volume for all local audibles, but		 * not any groups.		 * 		 * @param step The amount to decrease the volume level by.		 */		public function decreaseVolume(step:Number=.1):void		{			_internalGroup.decreaseVolume(step);		}				/**		 * Decrease a group's volume.		 * 		 * @param groupId The group id.		 * @param step The amount to dincrease the volume level by.		 */		public function decreaseVolumeForGroup(groupId:String,step:Number=.1):void		{			var group:AudibleGroup=audibleGroups[groupId];			group.decreaseVolume(step);		}				/**		 * Decrease the group ids provided, or if null,		 * all groups, but not any local audibles.		 */		public function decreaseVolumeForGroups(step:Number=.1,...groupIds:Array):void		{			var group:AudibleGroup;			if(!groupIds) for each(group in audibleGroups) group.decreaseVolume(step);			else			{				var i:int=0;				var l:int=groupIds.length;				for(i;i<l;i++)AudibleGroup(audibleGroups[groupIds[i]]).decreaseVolume(step);			}		}				/**		 * Mute's all local audibles, but not any groups.		 */		public function mute():void		{			_internalGroup.mute();		}				/**		 * Mutes all local audibles, and all group audibles.		 */		public function muteAll():void		{			_internalGroup.mute();			muteGroups();		}				/**		 * Mute all group ids provided, or if null,		 * mute all groups, but not any local audibles.		 * 		 * @param ...groupIds The groups to mute.		 */		public function muteGroups(...groupIds:Array):void		{			var group:AudibleGroup;			if(!groupIds)for each(group in audibleGroups)group.mute();			else			{				var i:int=0;				var l:int=groupIds.length;				for(i;i<l;i++)for each(group in audibleGroups) if(group.groupId==groupIds[i])group.mute();			}		}				/**		 * Unmutes all local audibles, but not any groups.		 */		public function unMute():void		{			_internalGroup.unMute();		}				/**		 * Unmutes all local audibles, and all groups.		 */		public function unMuteAll():void		{			_internalGroup.unMute();			unMuteGroups();		}				/**		 * Unmute all groups provided, or if null, all		 * groups will be unmuted, but not any local audibles.		 * 		 * @param ...groupIds The groups to unmute.		 */		public function unMuteGroups(...groupIds:Array):void		{			var group:AudibleGroup;			if(!groupIds) for each(group in audibleGroups)group.unMute();			else			{				var i:int=0;				var l:int=groupIds.length;				for(i;i<l;i++)for each(group in audibleGroups) if(group.groupId==groupIds[i])group.unMute();			}		}				/**		 * Set the volume for all local audibles,		 * but not any groups.		 */		public function setVolume(level:Number):void		{			_internalGroup.volume=level;		}				/**		 * Set the volume for a specific group.		 * 		 * @param groupId The group id.		 * @param level The new volume level for the group.		 */		public function setVolumeForGroup(groupId:String,level:Number):void		{			if(!doesGroupExist(groupId))return;			var group:AudibleGroup=audibleGroups[groupId];			group.volume=level;		}		/**		 * Set the volume for the groups specified, or if null,		 * all groups' volume will be updated.		 * 		 * @param level The new volume level.		 * @param ...groupIds The groups to update.		 */		public function setVolumeForGroups(level:Number,...groupIds:Array):void		{			var group:AudibleGroup;			if(!groupIds) for each(group in audibleGroups)group.volume=level;			else			{				var i:int=0;				var l:int=groupIds.length;				for(i;i<l;i++)				{					if(!doesGroupExist(groupIds[i]))continue;					group=AudibleGroup(audibleGroups[groupIds[i]]);					group.volume=level;				}			}		}				/**		 * Set the volume for all local audibles, and all		 * groups.		 * 		 * @param level The new volume level.		 */		public function setVolumeForAll(level:Number):void		{			_internalGroup.volume=level;			var group:AudibleGroup;			for each(group in audibleGroups)group.volume=level;		}				/**		 * Set a specific audible's volume in a group.		 * 		 * @param groupId The group id the audible resides in.		 * @param audibleId The audible id.		 * @param level The new volume level		 * @param persist Whether or not to persist the new volume level on subsequent plays of the same audible object.		 */		public function setVolumeForAudibleInGroup(groupId:String,audibleId:String,level:Number,persist:Boolean):void		{			if(!doesGroupExist(groupId))return;			AudibleGroup(audibleGroups[audibleId]).setVolumeForAudible(audibleId,level,persist);		}				/**		 * Get the volume of the local audibles.		 */		public function getVolume():Number		{			return _internalGroup.volume;		}				/**		 * Get the volume of a specific group. If the group		 * does not exist, -1 is returned.		 * 		 * @param groupId The group.		 */		public function getGroupVolume(groupId:String):Number		{			if(!doesGroupExist(groupId))return -1;			var group:AudibleGroup = audibleGroups[groupId];			return group.volume;		}				/**		 * Get a specific audible's volume from a group.		 * 		 * @param group The group the audible resides in.		 * @param audibleId The id of the audible.		 */		public function getVolumeForAudibleFromGroup(groupId:String,audibleId:String):Number		{			if(!doesGroupExist(groupId))return -1;			return AudibleGroup(audibleGroups[groupId]).volume;		}	}}