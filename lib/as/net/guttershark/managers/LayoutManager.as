package net.guttershark.managers{	import flash.geom.Point;		import flash.display.DisplayObject;	import flash.display.DisplayObjectContainer;	import flash.display.Stage;		/**	 * The LayoutManager class adds shortcuts for layout, and layer management	 * with a display objects' children - CoreClip and CoreSprite have an	 * instance of a layout manager already defined.	 * 	 * @example	Using a layout manager from a CoreClip.	 * <listing>		 * public class MyClip extends CoreClip	 * {	 *     public function MyClip()	 *     {	 *         super(); //critical	 *         	 *         var mc1:MovieClip = new MovieClip();	 *         //draw vector box in mc1 here...	 *        	 *         var mc2:MovieClip = new MovieClip();	 *         //draw vector box in mc2 here...	 *         	 *         var mc3:MovieClip = new MovieClip();	 *         //draw vector box in mc3 here...	 *         	 *         lm.addChildren(mc1,mc2,mc3); //shortcut to add multiple children.	 *         	 *         lm.arrange(Arrange.INFRONT,mc1,mc2); //moves mc1 in front of mc2.	 *         lm.arrange(Arrange.SEND_TO_BACK,mc1); //sends mc1 all the way to the back.	 *         lm.arrange(Arrange.BRING_FORWARD,mc2); //brings mc2 forward (in front of mc3).	 *     }	 * }	 * </listing>	 * 	 * @example Using a layout manager manually.	 * <listing>		 * var lm:LayoutManager = new LayoutManager(this);	 * 	 * var mc1:MovieClip = new MovieClip();	 * //draw box in mc1	 * 	 * var mc2:MovieClip = new MovieClip();	 * //draw box in mc2	 * 	 * var mc3:MovieClip = new MovieClip();	 * //draw box in mc3	 * 	 * lm.addChildren(mc1,mc2,mc3);	 * lm.bringToFront(mc1); //moves mc1 in front	 * </listing>	 * 	 * @see net.guttershark.display.CoreClip#lm CoreClip lm property	 * @see net.guttershark.display.CoreSprite#lm CoreSprite lm property	 */	final public class LayoutManager	{				/**		 * The container in which layering operations will occur.		 */		protected var container:DisplayObjectContainer;		/**		 * zero point		 */		private static var ZeroPoint:Point;		private static var FirstStageWidth:int;		private static var FirstStageHeight:int;		private static var StageRef:Stage;		/**		 * Constructor for LayoutManager instances. 		 */		public function LayoutManager(target:DisplayObjectContainer)		{			container = target;			if(!FirstStageHeight)			{				FirstStageHeight = target.stage.stageHeight;				FirstStageWidth = target.stage.stageWidth;				StageRef = target.stage;				ZeroPoint = new Point(0,0);			}		}				/**		 * Bring a target display object in front of another display object.		 * 		 * @param target The target display object to re-layer.		 * @param relativeTo The display object in which the target will be brought in front of.		 */		public function bringInFront(target:DisplayObject, relativeTo:DisplayObject):void		{			var index:int = container.getChildIndex(relativeTo);			if(index < container.getChildIndex(target)) index +=1;			if(index!=-1) container.setChildIndex(target,index);		}				/**		 * Send a target display object behind another display object.		 * 		 * @param target The target display object to re-layer.		 * @param relativeTo The display object in which the target will be moved behind.		 */		public function sendBehind(target:DisplayObject, relativeTo:DisplayObject):void		{			var index:int = container.getChildIndex(relativeTo);			if(index!=-1) container.setChildIndex(target,index);		}				/**		 * Bring a display object forward 1 layer.		 * 		 * @param target The target display object.		 */		public function bringForward(target:DisplayObject):void		{			var index:int = container.getChildIndex(target)+1;			if(index == container.numChildren) return;			if(index!=-1) container.setChildIndex(target,index);		}				/**		 * Send the target display object backward 1 layer.		 * 		 * @param target The target display object.		 */		public function sendBackward(target:DisplayObject):void		{			var index:int = Math.max(0,container.getChildIndex(target)-1);			container.setChildIndex(target,index);			if(index!=-1) container.setChildIndex(target,index);		}				/**		 * Bring the target display object to the top most layer.		 * 		 * @param target The target display object.		 */		public function bringToFront(target:DisplayObject):void		{			var index:int = container.numChildren-1;			container.setChildIndex(target,index);			if(index!=-1) container.setChildIndex(target,index);		}				/**		 * Send the target display object to bottom most layer.		 * 		 * @param target The target display object.		 */		public function sendToBack(target:DisplayObject):void		{			container.setChildIndex(target,0);		}				/**		 * Add all children specified to the display list.		 * 		 * @param ...children An array of display objects to add.		 */		public function addChildren(...children):void		{			for each(var child:DisplayObject in children) container.addChild(child);		}				/**		 * Add all children specified onto the display list of the target container.		 * 		 * @param target A display object to add the spefified children onto.		 * @param ...children An array of display objects to add.		 */		public function addChildrenTo(target:DisplayObjectContainer,...children):void		{			for each(var child:DisplayObject in children) target.addChild(child);		}		/**		 * Remove all children specified from the display list.		 * 		 * @param ...children The children to remove.		 */		public function removeChildren(...children):void		{			for each(var child:DisplayObject in children) container.removeChild(child);		}				/**		 * Remove all children from the display list.		 */		public function removeAllChildren():void		{			if(container.numChildren<1) return;			var i:int = 0;			var l:int = container.numChildren;			for(i;i<l;i++) container.removeChildAt(0);		}				/**		 * Remove all children from the display list of the specified target object.		 * 		 * @param target The target display object container whose children will be removed.		 */		public function removeAllChildrenFrom(target:DisplayObjectContainer):void		{			if(target.numChildren<1) return;			var i:int = 0;			var l:int = target.numChildren;			for(i;i<l;i++) target.removeChildAt(0);		}				/**		 * Check's that the container is on the display list.		 */		private function checkStage():void		{			if(!container.stage) throw new Error("The container for this layout manager must be on the display list.");		}				/**		 * Get's the properties needed for container coordinate translations.		 */		private function getProps(item:DisplayObject,target:DisplayObject):Object		{			var props:Object = {};			props.iw = item.width;			props.ih = item.height;			props.tw = target.width;			props.th = target.height;			props.tgp = target.localToGlobal(ZeroPoint);			props.ilp = item.parent.globalToLocal(props.tgp);			return props;		}		/**		 * Horizontally center align a display object to target - without adjusting		 * the vertical position.		 * 		 * @param item The item to arrange.		 * @param target The target display object that item will be horizontally aligned to.		 */		public function alignXCenter(item:DisplayObject,target:DisplayObject,wholePixels:Boolean=true):void		{			var props:Object = getProps(item,target);			if(wholePixels) item.x = Math.round(props.ilp.x + ((props.tw - props.iw) / 2));			else item.x = props.ilp.x + ((props.tw - props.iw) / 2);		}		/**		 * Vertically center align a display object to target - without adjusting		 * the horizontal position.		 * 		 * @param item The item to arrange.		 * @param target The target display object that item will be vercailly centered to.		 */		public function alignYCenter(item:DisplayObject,target:DisplayObject,wholePixels:Boolean=true):void 		{			var props:Object = getProps(item,target);			if(wholePixels) item.y = Math.round(props.ilp.y + ((props.th - props.ih) / 2));			else item.y = props.ilp.y + ((props.th - props.ih) / 2);		}				/**		 * Horizontally right align a display object to target - without adjusting		 * the vertical position.		 * 		 * @param item The item to arrange.		 * @param target The target display object that the item will be horizontally right aligned to.		 */		public function alignRight(item:DisplayObject,target:DisplayObject,wholePixels:Boolean=true):void		{			var props:Object = getProps(item,target);			if(wholePixels) item.x = Math.round(props.ilp.x + ((props.tw - props.iw)));			else item.x = props.ilp.x + ((props.tw - props.iw));		}				/**		 * Horizontally left align a display object to target - without adjusting		 * the vertical position.		 * 		 * @param item The item to arrange.		 * @param target The target display object that the item will be horizontally left aligned to.		 */			public function alignLeft(item:DisplayObject,target:DisplayObject,wholePixels:Boolean=true):void 		{			var props:Object = getProps(item,target);			if(wholePixels) item.x = Math.round(props.ilp.x);			else item.x = props.ilp.x;		}				/**		 * Vertically top align a display object to target - without adjusting		 * the horizontal position.		 * 		 * @param item The display object to align.		 * @param target The display object that item will be aligned to.		 */		public function alignTop(item:DisplayObject,target:DisplayObject,wholePixels:Boolean=true):void 		{			var props:Object = getProps(item,target);			if(wholePixels) item.y = Math.round(props.ilp.y);			else item.y = props.ilp.y;		}				/**		 * Vertically bottom align a display object to target - without adjusting		 * the horizontal position.		 * 		 * @param item The display object to align.		 * @param target The display object that item will be aligned to.		 */		public function alignBottom(item:DisplayObject,target:DisplayObject,wholePixels:Boolean=true):void 		{			var props:Object = getProps(item,target);			if(wholePixels) item.y = Math.round(props.ilp.y + (props.th-props.ih));			else item.y = props.ilp.y + props.th;		}				/**		 * Vertically and Horizontally center align a display object relative to the target.		 * 		 * @param item The item to arrange.		 * @param target The target display object that item will be centered in.		 */		public function alignCenter(item:DisplayObject,target:DisplayObject,wholePixels:Boolean=true):void		{			alignXCenter(item,target,wholePixels);			alignYCenter(item,target,wholePixels);		}				/**		 * Horizontally center align against the top edge of a target display object.		 * 		 * @param item The display object to align.		 * @param target The display object that item will be aligned against.		 */		public function alignTopCenter(item:DisplayObject,target:DisplayObject,wholePixels:Boolean=true):void		{			alignXCenter(item,target,wholePixels);			alignTop(item,target,wholePixels);		}				/**		 * Horizontally center align against the bottom edge of a target display object.		 * 		 * @param item The display object to align.		 * @param target The display object that item will be aligned against.		 */		public function alignBottomCenter(item:DisplayObject,target:DisplayObject,wholePixels:Boolean=true):void		{			alignXCenter(item,target,wholePixels);			alignBottom(item,target,wholePixels);		}				/**		 * Align a display object relatively to the top left of another display object.		 * 		 * @param item The display object to align.		 * @param The target display object that item will be aligned to.		 */		public function alignTopLeft(item:DisplayObject,target:DisplayObject,wholePixels:Boolean=true):void		{			alignLeft(item,target,wholePixels);			alignTop(item,target,wholePixels);		}				/**		 * Vertically left align a display object to target.		 * 		 * @param item The display object to align.		 * @param target The display objec that item will be aligned against.		 */		public function alignMiddleLeft(item:DisplayObject,target:DisplayObject,wholePixels:Boolean=true):void 		{			alignLeft(item,target,wholePixels);			alignYCenter(item,target,wholePixels);		}				/**		 * Align a display object relatively to the bottom left of another display object.		 * 		 * @param item The display object to align.		 * @param The target display object that item will be aligned to.		 */		public function alignBottomLeft(item:DisplayObject,target:DisplayObject,wholePixels:Boolean=true):void		{			alignLeft(item,target,wholePixels);			alignBottom(item,target,wholePixels);		}				/**		 * Align a display object relatively to the top right of another display object.		 * 		 * @param item The display object to align.		 * @param The target display object that item will be aligned to.		 */		public function alignTopRight(item:DisplayObject,target:DisplayObject,wholePixels:Boolean=true):void		{			alignRight(item,target,wholePixels);			alignTop(item,target,wholePixels);		}				/**		 * Vertically right align a display object to target.		 * 		 * @param item The display object to align.		 * @param target The display object that item will be aligned agains.		 */		public function alignMiddleRight(item:DisplayObject,target:DisplayObject,wholePixels:Boolean=true):void		{			alignRight(item,target,wholePixels);			alignYCenter(item,target,wholePixels);		}				/**		 * Align a display object relatively to the bottom right of another display object.		 * 		 * @param item The display object to align.		 * @param The target display object that item will be aligned to.		 */		public function alignBottomRight(item:DisplayObject,target:DisplayObject,wholePixels:Boolean=true):void		{			alignRight(item,target,wholePixels);			alignBottom(item,target,wholePixels);		}				private function propsForStageAligns(item:DisplayObject):Object		{			var props:Object = {};			props.iw = item.width;			props.ih = item.height;			return props;		}				private function updatePointXForStageAdjustments(p:Point):Point		{			trace(container.stage.stageWidth);			trace(container.stage.width);			trace(FirstStageWidth);			if(StageRef.stageHeight == FirstStageHeight && StageRef.stageWidth == FirstStageWidth) return p;			if(!(StageRef.align) || StageRef.align == "T" || StageRef.align=="B")			{				if(FirstStageWidth < StageRef.stageWidth) p.x -= (StageRef.stageWidth - FirstStageWidth) / 2;				else p.x += (FirstStageWidth - StageRef.stageWidth) / 2;			}			return p;		}				private function updatePointYForStageAdjustments(p:Point):Point		{			trace(container.stage.stageWidth);			trace(container.stage.width);			trace(FirstStageWidth);			if(StageRef.stageHeight == FirstStageHeight && StageRef.stageWidth == FirstStageWidth) return p;			if(!(StageRef.align))			{				if(FirstStageHeight < StageRef.stageHeight) p.y -= (StageRef.stageHeight - FirstStageHeight) / 2;				else p.y += (FirstStageHeight - StageRef.stageHeight) / 2;			}			return p;		}				/**		 * Horizontally center align a display object to the stage.		 * 		 * @param item The item to horizontally center align.		 */		public function stageAlignXCenter(item:DisplayObject):void		{			var props:Object = propsForStageAligns(item);			var nx:int = (container.stage.stageWidth - props.iw) / 2;			var p:Point = new Point(nx,0);			var np:Point = item.parent.globalToLocal(p);			np = updatePointXForStageAdjustments(np);			item.x = np.x;		}		/**		 * Vertically center align a display object to the stage.		 * 		 * @param item The item to veritcally center align.		 */		public function stageAlignYCenter(item:DisplayObject):void		{			var props:Object = propsForStageAligns(item);			var ny:int = (container.stage.stageHeight - props.ih) / 2;			var p:Point = new Point(0,ny);			var np:Point = item.parent.globalToLocal(p);			np = updatePointYForStageAdjustments(np);			item.y = np.y;		}				/**		 * Center align a display object to the stage.		 * 		 * @param item The item to center align.		 */		public function stageAlignCenter(item:DisplayObject,wholePixels:Boolean=true):void		{			checkStage();			stageAlignXCenter(item);			stageAlignYCenter(item);		}				/**		 * Align a display object to the right edge of the stage.		 * 		 * @param item The item to right align.		 */		public function stageAlignRight(item:DisplayObject):void 		{			var props:Object = propsForStageAligns(item);			var nx:int = (container.stage.stageWidth - props.iw);			var p:Point = new Point(nx,0);			var np:Point = item.parent.globalToLocal(p);			np = updatePointXForStageAdjustments(np);			item.x = np.x;		}			/**		 * Align a display object to the left edge of the stage.		 * 		 * @param item The display object to align.		 */		public function stageAlignLeft(item:DisplayObject):void		{			var p:Point = new Point(0,0);			var np:Point = item.parent.globalToLocal(p);			np = updatePointXForStageAdjustments(np);			item.x = np.x;		}		/**		 * Align a display object to the bottom edge of the stage.		 * 		 * @param item The item to bottom align.		 */		public function stageAlignBottom(item:DisplayObject):void		{			var props:Object = propsForStageAligns(item);			var ny:int = (container.stage.stageHeight - props.ih);			var p:Point = new Point(0,ny);			var np:Point = item.parent.globalToLocal(p);			np = updatePointYForStageAdjustments(np);			item.y = np.y;		}				public function stageAlignTop(item:DisplayObject):void		{			var p:Point = item.parent.globalToLocal(ZeroPoint);			p = updatePointYForStageAdjustments(p);			item.y = p.y;		}				public function stageAlignMiddleRight(item:DisplayObject):void		{			stageAlignRight(item);			stageAlignYCenter(item);		}				public function stageAlignMiddleLeft(item:DisplayObject):void		{			stageAlignLeft(item);			stageAlignYCenter(item);		}				public function stageAlignTopCenter(item:DisplayObject):void		{			stageAlignTop(item);			stageAlignXCenter(item);		}				public function stageAlignBottomCenter(item:DisplayObject):void		{			stageAlignBottom(item);			stageAlignXCenter(item);		}				/**		 * 		 */		public function stageAlignTopRight(item:DisplayObject):void		{			stageAlignRight(item);			stageAlignTop(item);		}				/**		 * 		 */		public function stageAlignBottomRight(item:DisplayObject):void		{			stageAlignBottom(item);			stageAlignRight(item);		}				/**		 * 		 */		public function stageAlignBottomLeft(item:DisplayObject):void		{			stageAlignLeft(item);			stageAlignBottom(item);		}				/**		 * 		 */		public function stageAlignTopLeft(item:DisplayObject):void		{			stageAlignTop(item);			stageAlignLeft(item);		}			}}