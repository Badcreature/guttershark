package net.guttershark.managers{	import flash.display.DisplayObject;	import flash.display.DisplayObjectContainer;	import flash.display.Stage;		import net.guttershark.support.layoutmanager.Arrange;	
	/**	 * The LayoutManager class adds shortcuts for layout, and layer management	 * with a display objects children. CoreClip and CoreSprite have an	 * instnace of a layout manager already defined.	 * 	 * @example	Using a layout manager from a CoreClip.	 * <listing>		 * public class MyClip extends CoreClip	 * {	 *     public function MyClip()	 *     {	 *         super(); //critical	 *         	 *         var mc1:MovieClip = new MovieClip();	 *         //draw vector box in mc1 here...	 *        	 *         var mc2:MovieClip = new MovieClip();	 *         //draw vector box in mc2 here...	 *         	 *         var mc3:MovieClip = new MovieClip();	 *         //draw vector box in mc3 here...	 *         	 *         lm.addChildren(mc1,mc2,mc3); //shortcut to add multiple children.	 *         	 *         lm.arrange(Arrange.INFRONT,mc1,mc2); //moves mc1 in front of mc2.	 *         lm.arrange(Arrange.SEND_TO_BACK,mc1); //sends mc1 all the way to the back.	 *         lm.arrange(Arrange.BRING_FORWARD,mc2); //brings mc2 forward (in front of mc3).	 *     }	 * }	 * </listing>	 * 	 * @example Using a layout manager manually.	 * <listing>		 * var lm:LayoutManager = new LayoutManager(this);	 * 	 * var mc1:MovieClip = new MovieClip();	 * //draw box in mc1	 * 	 * var mc2:MovieClip = new MovieClip();	 * //draw box in mc2	 * 	 * var mc3:MovieClip = new MovieClip();	 * //draw box in mc3	 * 	 * lm.addChildren(mc1,mc2,mc3);	 * lm.arrange(Arrange.BRING_TO_FRONT,mc1); //moves mc1 in front	 * </listing>	 * 	 * @see net.guttershark.display.CoreClip#lm CoreClip lm property	 * @see net.guttershark.display.CoreSprite#lm CoreSprite lm property	 */	public class LayoutManager	{				/**		 * The container in which layering operations will occur.		 */		protected var container:DisplayObjectContainer;		/**		 * Constructor for LayoutManager instances. 		 */		public function LayoutManager(target:DisplayObjectContainer)		{			container = target;		}				/**		 * Arrange the target display object, relative to the supplied <em><code>relativeTo</code></em>		 * display object.		 * 		 * @param arrangement An arrangement command (see: net.guttershark.support.layoutmanager.Arrange).		 * @param target The target display object to re-arrange.		 * @param relativeTo The display object in which the target will be relatively arranged from.		 */		public function arrange(arrangement:String,target:*,relativeTo:DisplayObject=null):void 		{			if(!container.contains(target)) return;			if(target === relativeTo) return;			var index:Number=-1;			switch(arrangement)			{				case Arrange.SEND_TO_BACK:					index = 0;					break;				case Arrange.BRING_TO_FRONT:					index = container.numChildren-1;					break;				case Arrange.SEND_BACKWARD:					index = Math.max(0,container.getChildIndex(target)-1);					break;				case Arrange.BRING_FORWARD:					index = container.getChildIndex(target)+1;					if(index == container.numChildren) return;					break;				case Arrange.BEHIND:					index = container.getChildIndex(relativeTo);					break;				case Arrange.INFRONT:					index = container.getChildIndex(relativeTo);					if(index < container.getChildIndex(target)) index +=1;					break;			}			if(index!=-1) container.setChildIndex(target,index);		}				/**		 * Add all children specified to the display list.		 * 		 * @param ...children An array of display objects to add.		 */		public function addChildren(...children):void		{			for each(var child:DisplayObject in children) container.addChild(child);		}				/**		 * Add all children specified onto the display list of the target container.		 * 		 * @param target A display object to add the spefified children onto.		 * @param ...children An array of display objects to add.		 */		public function addChildrenTo(target:DisplayObjectContainer,...children):void		{			for each(var child:DisplayObject in children) target.addChild(child);		}		/**		 * Remove all children specified from the display list.		 * 		 * @param ...children The children to remove.		 */		public function removeChildren(...children):void		{			for each(var child:DisplayObject in children) container.removeChild(child);		}				/**		 * Remove all children from the display list.		 */		public function removeAllChildren():void		{			if(container.numChildren<1) return;			try{while(container.removeChildAt(0)){}}catch(re:RangeError){}		}				/**		 * Remove all children from the display list of the specified target object.		 * 		 * @param target The target display object container whose children will be removed.		 */		public function removeAllChildrenFrom(target:DisplayObjectContainer):void		{			if(target.numChildren<1) return;			try{while(target.removeChildAt(0)){}}catch(re:RangeError){}		}				/**		 * Center align a display object relative to the target.		 * 		 * @param item The item to arrange.		 * @param target The target display object that item will be centered in.		 */		public function alignCenter(item:DisplayObject,target:DisplayObject):void		{			xAlignCenter(item,target);			yAlignCenter(item,target);		}		/**		 * Horizontally center align a display object to target.		 * 		 * @param item The item to arrange.		 * @param target The target display object that item will be horizontally aligned to.		 */		public function xAlignCenter(item:DisplayObject,target:DisplayObject):void 		{			item.x = int(target.width / 2 - item.width / 2);		}		/**		 * Vertically center align a display object to target.		 * 		 * @param item The item to arrange.		 * @param target The target display object that item will be vercailly centered to.		 */		public function yAlignCenter(item:DisplayObject,target:DisplayObject):void 		{			item.y = int(target.height / 2 - item.height / 2);		}		/**		 * Right align a display object to target.		 * 		 * @param item The item to arrange.		 * @param target The target display object that item will be right aligned to.		 */		public function alignRight(item:DisplayObject,target:DisplayObject):void 		{			xAlignRight(item,target);			yAlignRight(item,target);		}		/**		 * Horizontally right align a display object to target.		 * 		 * @param item The item to arrange.		 * @param target The target display object that the item will be horizontally right aligned to.		 */		public function xAlignRight(item:DisplayObject,target:DisplayObject):void 		{			item.x = int(target.width - item.width);		}		/**		 * Vertically right align a display object to target.		 * 		 * @param item The item to arrange.		 * @param target The target display object that the item will be vertically right aligned to.		 */		public function yAlignRight(item:DisplayObject,target:DisplayObject):void 		{			item.y = int(target.height - item.height);		}		/**		 * Left align a display object to target.		 * 		 * @param item The item to arrange.		 * @param target The target display object that the item will be left aligned to.		 */		public function alignLeft(item:DisplayObject,target:DisplayObject):void 		{			xAlignLeft(item,target);			yAlignLeft(item,target);		}		/**		 * Horizontally left align a display object to target.		 * 		 * @param item The item to arrange.		 * @param target The target display object that the item will be horizontally left aligned to.		 */			public function xAlignLeft(item:DisplayObject,target:DisplayObject):void 		{			item.x = int(target.x);		}		/**		 * Vertically left align a display object to target.		 * 		 * @param item The item to arrange.		 * @param target The target display object that the item will be vertically left aligned to.		 */			public function yAlignLeft(item:DisplayObject,target:DisplayObject):void 		{			item.y = int(target.y);		}		/**		 * Center align a display object to the stage.		 * 		 * @param item The item to center align.		 */		public function stageAlignCenter(item:DisplayObject):void		{			checkStage();			stageAlignXCenter(item);			stageAlignYCenter(item);		}		/**		 * Check's that the container is on the display list.		 */		private function checkStage():void		{			if(!container.stage) throw new Error("The container for this layout manager must be on the display list.");		}		/**		 * Horizontally center align a display object to the stage.		 * 		 * @param item The item to horizontally center align.		 */		public function stageAlignXCenter(item:DisplayObject):void		{			checkStage();			item.x=int(container.stage.stageWidth/2-item.width/2);		}		/**		 * Vertically center align a display object to the stage.		 * 		 * @param item The item to veritcally center align.		 */		public function stageAlignYCenter(item:DisplayObject):void		{			checkStage();			item.y=int(container.stage.stageHeight/2-item.height/2);		}		/**		 * Align a display object to the right edge of the stage.		 * 		 * @param item The item to right align.		 */		public function stageAlignRight(item:DisplayObject):void 		{			checkStage();			item.x=int(container.stage.stageWidth-item.width);		}		/**		 * Align a display object to the bottom edge of the stage.		 * 		 * @param item The item to bottom align.		 */		public function stageAlignBottom(item:DisplayObject):void		{			checkStage();			item.y=int(container.stage.stageHeight-item.height);		}		/**		 * Set the scale of an object; this updates the scale for both x and y.		 * 		 * @param item The target item to scale. 		 * @param scale	The scale percentage.		 */		public function scale(item:DisplayObject,scale:Number):void 		{			item.scaleX = scale;			item.scaleY = scale;		}		/**		 * Scale target item to fit within target confines.		 * 		 * @param item The item to be aligned.		 * @param targetW The target item width.		 * @param targetH The target item height.		 * @param center Center the object within the targetW and targetH.		 */		public function scaleToFit(item:DisplayObject,targetW:Number,targetH:Number,center:Boolean):void		{			if(item.width<targetW && item.width>item.height) 			{				item.width = targetW;				item.scaleY = item.scaleX;			}			else			{				item.height = targetH;				item.scaleX = item.scaleY;			}			if(center) 			{				item.x = int(targetW/2-item.width/2);				item.y = int(targetH/2-item.height/2);			}		}		/**		 * Scale while retaining original w:h ratio.		 * 		 * @param item The item to be scaled.		 * @param targetW The target item width.		 * @param targetH The target item height.		 */		public function scaleRatio(item:DisplayObject,targetW:Number,targetH:Number):void		{			if(targetW/targetH<item.height/item.width) targetW = targetH * item.width / item.height; 			else targetH = targetW * item.height / item.width;			item.width = targetW;			item.height = targetH;		}		/**		 * Flip object on an the x or y axis.		 * 		 * @param obj The object to flip		 * @param axis The axis to flip on - "x" or "y"		 */		public function flip(obj:Object,axis:String="y"):void		{			if(axis != "_x" && axis != "_y") 			{				throw new Error("Error: flip expects axis param: 'x' or 'y'.");				return;			}			var _scale:String = axis == "x" ? "scaleX" :"scaleY";			var _prop:String = axis == "x" ? "width" : "height";			obj[_scale] = -obj[_scale];			obj[axis] -= obj[_prop];		}	}}