package net.guttershark.managers{	import flash.display.DisplayObject;	import flash.display.DisplayObjectContainer;		import net.guttershark.support.layoutmanager.Arrange;	/**	 * The LayoutManager Class adds support for "layer" management	 * with a display objects children. The LayoutManager is	 * a "lazy decorator," meaning that you use it's functionality	 * by creating your own property in a subclassed object and use that property	 * to affect the object it's attached to. CoreClip and CoreSprite have	 * a property declared on them called <em><code>lm</code></em>, which 	 * stands for layout manager, which is an example of lazy decorator.	 * 	 * @example	Using a layout manager from a CoreClip.	 * <listing>		 * public class MyClip extends CoreClip	 * {	 *     public function MyClip()	 *     {	 *         super(); //critical	 *         	 *         var mc1:MovieClip = new MovieClip();	 *         //draw vector box in mc1 here...	 *        	 *         var mc2:MovieClip = new MovieClip();	 *         //draw vector box in mc2 here...	 *         	 *         var mc3:MovieClip = new MovieClip();	 *         //draw vector box in mc3 here...	 *         	 *         lm.addChildren(mc1,mc2,mc3); //shortcut to add multiple children.	 *         	 *         lm.arrange(Arrange.INFRONT,mc1,mc2); //moves mc1 in front of mc2	 *         lm.arrange(Arrange.SEND_TO_BACK,mc1); //sends mc1 all the way to the back.	 *         lm.arrange(Arrange.BRING_FORWARD,mc2); //brings mc2 forward (in front of mc3).	 *     }	 * }	 * </listing>	 * 	 * @example Using a layout manager manually.	 * <listing>		 * var lm:LayoutManager = new LayoutManager(this);	 * 	 * var mc1:MovieClip = new MovieClip();	 * //draw box in mc1	 * 	 * var mc2:MovieClip = new MovieClip();	 * //draw box in mc2	 * 	 * var mc3:MovieClip = new MovieClip();	 * //draw box in mc3	 * 	 * lm.addChildren(mc1,mc2,mc3);	 * lm.arrange(Arrange.BRING_TO_FRONT,mc1); //moves mc1 in front	 * </listing>	 * 	 * @see net.guttershark.display.CoreClip#lm CoreClip lm property	 * @see net.guttershark.display.CoreSprite#lm CoreSprite lm property	 */	public class LayoutManager	{				/**		 * The container in which layering operations will occur.		 */		protected var container:DisplayObjectContainer;		/**		 * Constructor for LayoutManager instances. 		 */		public function LayoutManager(target:DisplayObjectContainer)		{			container = target;		}				/**		 * Arrange the target display object, relative to the supplied <em><code>relativeTo</code></em>		 * display object.		 * 		 * @param arrangement	An arrangement command (see: net.guttershark.support.layoutmanager.Arrange).		 * @param target	The target display object to re-arrange.		 * @param relativeTo	The display object in which the target will be relatively arranged from.		 */		public function arrange(arrangement:String,target:*,relativeTo:DisplayObject=null):void 		{			if(!container.contains(target)) return;			if(target === relativeTo) return;			var index:Number=-1;			switch(arrangement)			{				case Arrange.SEND_TO_BACK:					index = 0;					break;				case Arrange.BRING_TO_FRONT:					index = container.numChildren-1;					break;				case Arrange.SEND_BACKWARD:					index = Math.max(0,container.getChildIndex(target)-1);					break;				case Arrange.BRING_FORWARD:					index = container.getChildIndex(target)+1;					if(index == container.numChildren) return;					break;				case Arrange.BEHIND:					index = container.getChildIndex(relativeTo);					break;				case Arrange.INFRONT:					index = container.getChildIndex(relativeTo);					if(index < container.getChildIndex(target)) index +=1;					break;			}			if(index!=-1) container.setChildIndex(target,index);		}				/**		 * Add all children specified to the display list.		 * 		 * @param	...children	An array of display objects to add.		 */		public function addChildren(...children):void		{			for each(var child:DisplayObject in children) container.addChild(child);		}				/**		 * Add all children specified onto the display list of the target container.		 * 		 * @param	target	A display object to add the spefified children onto.		 * @param	...children	An array of display objects to add.		 */		public function addChildrenTo(target:DisplayObjectContainer,...children):void		{			for each(var child:DisplayObject in children) target.addChild(child);		}		/**		 * Remove all children specified from the display list.		 * 		 * @param ...children The children to remove.		 */		public function removeChildren(...children):void		{			for each(var child:DisplayObject in children) container.removeChild(child);		}				/**		 * Remove all children from the display list.		 */		public function removeAllChildren():void		{			if(container.numChildren<1) return;			try{while(container.removeChildAt(0)){}}catch(re:RangeError){}		}				/**		 * Remove all children from the display list of the specified target object.		 * 		 * @param	target	The target display object container whose children will be removed.		 */		public function removeAllChildrenFrom(target:DisplayObjectContainer):void		{			if(target.numChildren<1) return;			try{while(target.removeChildAt(0)){}}catch(re:RangeError){}		}	}}