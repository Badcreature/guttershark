package net.guttershark.display.video{	import flash.display.Sprite;	import flash.events.Event;	import flash.events.EventDispatcher;	import flash.events.NetStatusEvent;	import flash.media.SoundTransform;	import flash.media.Video;	import flash.net.NetConnection;	import flash.net.NetStream;	import flash.utils.setTimeout;		import net.guttershark.support.events.FLVEvent;	import net.guttershark.util.FramePulse;			/* 	 * The standard netStream.bufferTime will fire cuePoints out of order	 * so custom smart buffer is utilized.	 * http://www.restlessthinker.com/blog/?p=44	 */
	/**	 * FLV provides a common media control object.	 */	public class FLV extends Sprite	{		public var traceForDebug:Boolean = true;		public var playActsAsResume:Boolean = false;		protected var stream:NetStream;		protected var nc:NetConnection;		protected var client:Object;		protected var display:Video;
		protected var url:String;		protected var paused:Boolean;		protected var started:Boolean;		protected var duration:Number;		protected var metadata:Object;		protected var lastSeekableTime:Number;		protected var bufferTime:Number;		protected var bufferPause:Boolean;				/**		 * Constructor for FLV instances.		 * 		 * @param pixelsToFill The amount of pixels to fill for a progress status bar.		 * @param width The width of the video object.		 * @param height The height of the video object.		 * @param smoothing Whether or not smoothing is applied.		 */		public function FLV(pixelsToFill:int=100,width:int=320,height:int=240,smoothing:Boolean=true) 		{			super();			paused = false;			started = false;			display = new Video(width,height);			display.smoothing = smoothing;			duration = 1000000000; //fix for buffer bar flakiness		}		/**		 * Load the video.		 * 		 * @param url The url of the FLV to load.		 * @param buffer Seconds of buffer to maintain.		 */		public function load(url:String,buffer:uint=4,showFirstFrame:Boolean=true):void		{			this.url = url;			bufferTime = buffer;			nc = new NetConnection();			nc.connect(null);			client = new Object();			stream = new NetStream(nc);			display.attachNetStream(stream);			stream.client = this;			stream.addEventListener(NetStatusEvent.NET_STATUS,onNSStatus,false,0,true);			FramePulse.AddEnterFrameListener(onProgress);			play();			pause();			if(showFirstFrame) setTimeout(seek,500,0);		}				/**		 * Play the flv.		 */		public function play():void		{			display.clear();			started = true;			paused = false;			stream.seek(0);			stream.play(url);		}		/**		 * Stop the flv.		 */		public function stop():void		{			stream.pause();			started = false;			paused = false; //TODO should this be true?		}		/**		 * Pause the FLV.		 */		public function pause():void 		{			if(!paused && started)			{				paused = true;				stream.pause();			}		}		/**		 * Resume the FLV playback.		 */		public function resume():void		{			if(paused && started)			{				paused = false;				stream.resume();			}		}		/**		 * Toggles pause/resume.		 */		public function pauseResume():void		{			if(paused) resume();			else pause();		}		/**		 * Seek to a playback time - note that unless you're using		 * a flash media server, it will only seek to the nearest		 * key frame (i-frame) (see video docs in flash help for more info).		 * 		 * @param time The time in seconds to seek to.		 */		public function seek(time:Number):void		{			stream.seek(resolveTime(time));		}		/**		 * Seek to a playback percent (1 based %).		 * 		 * @param percent of playback to seek to.		 */		public function seekToPercent(percent:Number):void		{			seek(duration*percent/1);		}				/**		 * Seek to a width based off of the pixels to fill		 * (pixelsToFill) property.		 * 		 * @param width The width to seek to.		 */		public function seekToWidth(width:int):void		{		}		/**		 * Fast-forward playback.		 * 		 * @param step seconds to step forward.		 */		public function forward(step:Number = 2):void		{			seek(getTime()+step);		}		/**		 * Rewind playback.		 * 		 * @param step seconds to step backwards.		 */		public function rewind(step:Number = 2):void 		{			seek(getTime()-step);		}				/**		 * Check if the FLV is paused.		 */		public function isPaused():Boolean		{			return paused;		}		/**		 * Check if the FLV is playing.		 */		public function isPlaying():Boolean 		{			return started;		}		/**		 * Check if the FLV is stopped.		 */		public function isStopped():Boolean		{			return !started;		}		/**		 * Return the playback time.		 */		public function getTime():Number		{			return stream.time;		}		/**		 * Return the total playback duration.		 */		public function getDuration():Number		{				return duration;		}		/**		 * Return the percent played (1 based %).		 */		public function getPercentPlayed():Number		{			return getTime() * 1 / duration;		}						/**		 * Return the percent loaded (1 based %).		 */		public function getPercentLoaded():Number		{			return Math.round(stream.bytesLoaded/stream.bytesTotal * 1);		}		/**		 * Return the percent buffered (1 based %).		 */		public function getPercentBuffered():Number		{			var total:Number = Math.min(duration,bufferTime);			return Math.min(Math.round(stream.bufferLength/total * 1),100);		}						/**		 * Set the video volume.		 * 		 * @param volume The volume level - 0-1.		 */		public function setVolume(volume:Number):void		{			var st:SoundTransform = stream.soundTransform;			st.volume = volume;			stream.soundTransform = st;		}		/**		 * The internal video object used to display the		 * flv.		 */		public function get video():Video		{			return display;			}		/**		 * The internal net stream being used for this video.		 */		public function get netStream():NetStream 		{			return stream;			}		/**		 * Formats time so that it fits inside the available seek scope.		 * 		 * @param time The time from the net stream.		 */		protected function resolveTime(time:Number):Number		{			var maxTime:Number = (!isNaN(lastSeekableTime))?lastSeekableTime:duration;			return Math.max(Math.min(time,maxTime),0);		}		/**		 * Stop playback and cleanup after self.		 */		public function dispose():void		{			stop();			FramePulse.RemoveEnterFrameListener(onProgress);			stream.removeEventListener(NetStatusEvent.NET_STATUS,onNSStatus);			display.clear();			stream.close();			nc.close();			display = null;			stream = null;			nc = null;			client = null;		}				/**		 * Handles buffer logic, instead of using net stream		 * buffer time.		 */		protected function checkBuffer():void 		{			//trace("check buffer");			//outta buffer!			if(getPercentLoaded() <= getPercentBuffered())			{				//VIDEO HAS FINISHED PLAYING				if(getPercentLoaded() >= 1) return;				bufferPause = true;				dispatchEvent(new FLVEvent(FLVEvent.REBUFFER));			}			else			{				if(bufferPause)				{					//resume playback					bufferPause = false;					dispatchEvent(new FLVEvent(FLVEvent.REBUFFER_COMPLETE));				}			}		}		/**		 * Progress frame loop to keep client progress up to date.		 */		protected function onProgress(e:Event):void		{			//trace("on progress");			dispatchEvent(new FLVEvent(FLVEvent.PROGRESS,NaN,getPercentLoaded(),getPercentPlayed()));			//if(getPercentLoaded() == 1) FramePulse.RemoveEnterFrameListener(onProgress);			checkBuffer();		}		/**		 * NetStatus handler.		 */		protected function onNSStatus(stats:NetStatusEvent):void		{			if(traceForDebug) trace("netstat: ",stats.info['code']);			switch (stats.info['code'])			{				case "NetStream.Buffer.Empty":					dispatchEvent(new FLVEvent(FLVEvent.BUFFER_EMPTY));					break;				case "NetStream.Buffer.Full":					dispatchEvent(new FLVEvent(FLVEvent.BUFFER_FULL));					break;				case "NetStream.Buffer.Flush":					dispatchEvent(new FLVEvent(FLVEvent.BUFFER_FLUSH));					break;				case "NetStream.Play.Start":					dispatchEvent(new FLVEvent(FLVEvent.START));					break;				case "NetStream.Play.Stop":					dispatchEvent(new FLVEvent(FLVEvent.STOP));					break;				case "NetStream.Play.StreamNotFound":					dispatchEvent(new FLVEvent(FLVEvent.STREAM_NOT_FOUND));					break;				case "NetStream.Seek.InvalidTime":					dispatchEvent(new FLVEvent(FLVEvent.SEEK_INVALID_TIME));					break;				case "NetStream.Seek.Notify":					dispatchEvent(new FLVEvent(FLVEvent.SEEK_NOTIFY));					break;			}					}		/**		 * @private		 * 		 * Net CuePoint handler.		 */		public function onCuePoint(infoObject:Object):void		{ 			dispatchEvent(new FLVEvent(FLVEvent.CUE_POINT,NaN,NaN,null,infoObject));		}				/**		 * @private		 * 		 * Meta data handler.		 */		public function onMetaData(metadata:Object):void		{			metadata = metadata;			duration = metadata.duration;			lastSeekableTime = metadata.lastkeyframetimestamp;			dispatchEvent(new FLVEvent(FLVEvent.METADATA,NaN,NaN,metadata));		}							}}		